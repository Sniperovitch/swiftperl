import CPerl

final class PerlCV : PerlValue, PerlDerived {
	typealias UnsafeValue = UnsafeCV

	convenience init(noinc sv: UnsafeSvPointer, perl: UnsafeInterpreterPointer) throws {
		try self.init(_noinc: sv, perl: perl)
	}

	@discardableResult
	convenience init(name: String?, perl: UnsafeInterpreterPointer = UnsafeInterpreter.current, file: StaticString = #file, body: @escaping CvBody) {
		let cv = perl.pointee.newCV(name: name, file: file, body: body) // FIXME Why result is non-optional???
		let sv = UnsafeMutableRawPointer(cv).bindMemory(to: UnsafeSV.self, capacity: 1)
		self.init(noincUnchecked: sv, perl: perl)
		if name != nil {
			sv.pointee.refcntInc()
		}
	}

	func withUnsafeCvPointer<R>(_ body: (UnsafeCvPointer, UnsafeInterpreterPointer) throws -> R) rethrows -> R {
		return try withUnsafeSvPointer { sv, perl in
			return try sv.withMemoryRebound(to: UnsafeCV.self, capacity: 1) {
				return try body($0, perl)
			}
		}
	}

	var file: String {
		return withUnsafeCvPointer { cv, _ in cv.pointee.file }
	}

	override var debugDescription: String {
		let deparse: PerlObject = try! perl.pointee.eval("use B::Deparse; B::Deparse->new('-sCi0')")
		var text: String = try! deparse.call(method: "coderef2text", self)
		text = text.characters.split { $0 == "\n" } .map(String.init).joined(separator: " ")
		return "PerlCV(\(text) at \(file))"
	}
}

%{
	def generic(p, r):
		g = ", ".join(map(lambda n: "P" + str(n) + ": PerlSvConvertible", range(0, p)) + map(lambda n: "R" + str(n) + ": PerlSvConvertible", range(0, r)))
		return "" if g == "" else "<" + g + ">"

	def tuple(prefix, count, optional):
		if optional == 0:
			return "(" + ", ".join(map(lambda n: prefix + str(n), range(0, count))) + ")"
		elif optional == 1:
			return "(" + ", ".join(map(lambda n: prefix + str(n) + "?", range(0, count))) + ")"
		else:
			return "(" + ", ".join([prefix + "0"] + map(lambda n: prefix + str(n) + "?", range(1, count))) + ")"

	def optrange(count):
		return range(0, (count + 1) if count < 3 else 3)
}%

extension PerlCV {
% for p in range(0, 8):
%   for r in range(0, 3):
%     args = ", ".join(map(lambda n: "P" + str(n) + ".fromUnsafeSvPointer(stack[" + str(n) + "], perl: stack.perl)", range(0, p)))
%     for po in optrange(p):
%       for ro in optrange(r):

	@discardableResult
	convenience init${generic(p, r)}(name: String? = nil, file: StaticString = #file, body: @escaping ${tuple("P", p, po)} throws -> ${tuple("R", r, ro)}) {
		self.init(name: name, file: file) {
			(stack: UnsafeXSubStack) in
%         if r == 0:
			try body(${args})
			stack.xsReturn(EmptyCollection())
%         elif r == 1:
			let result = try body(${args})
			stack.xsReturn(CollectionOfOne(result.toUnsafeSvPointer(perl: stack.perl)))
%         else:
			let result = try body(${args})
			let svResult: ContiguousArray = [ ${", ".join(map(lambda n: "result." + str(n) + ".toUnsafeSvPointer(perl: stack.perl)", range(0, r)))} ]
			stack.xsReturn(svResult)
%         end
		}
	}

%       end
%     end
%   end
% end
}

extension PerlCV {
	@discardableResult
	convenience init<R: Collection>(name: String? = nil, file: StaticString = #file, body: @escaping ([PerlSV]) throws -> R)
		where R.Iterator.Element == PerlSV {
		self.init(name: name, file: file) {
			(stack: UnsafeXSubStack) in
			let args = try stack.args.map { try PerlSV.fromUnsafeSvPointer($0, perl: stack.perl) }
			let result = try body(args)
			stack.xsReturn(result.map { $0.toUnsafeSvPointer(perl: stack.perl) })
		}
	}
}

extension PerlBridgedObject {
% for p in range(0, 8):
%   for r in range(0, 3):
%     for po in optrange(p):
%       for ro in optrange(r):

	@discardableResult
	static func createPerlMethod${generic(p, r)}(_ method: String, file: StaticString = #file, body: @escaping ${tuple("P", p, po)} throws -> ${tuple("R", r, ro)}) -> PerlCV {
		return PerlCV(name: perlClassName + "::" + method, file: file, body: body)
	}

%       end
%     end
%   end
% end

	@discardableResult
	static func createPerlMethod<R: Collection>(_ method: String, file: StaticString = #file, body: @escaping ([PerlSV]) throws -> R) -> PerlCV
		where R.Iterator.Element == PerlSV {
		return PerlCV(name: perlClassName + "::" + method, file: file, body: body)
	}
}
