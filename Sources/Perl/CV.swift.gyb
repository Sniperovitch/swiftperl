import CPerl

final class PerlCV : PerlSVProtocol {
	typealias Struct = UnsafeCV
	typealias Pointer = UnsafeCvPointer
	let pointer: Pointer
	let perl: UnsafeInterpreterPointer

	init(_ p: Pointer, perl: UnsafeInterpreterPointer = UnsafeInterpreter.current) {
		self.perl = perl
		pointer = p
		pointer.pointee.refcntInc()
	}

	@discardableResult
	init(name: String?, perl: UnsafeInterpreterPointer = UnsafeInterpreter.current, file: StaticString = #file, body: @escaping CvBody) {
		self.perl = perl
		pointer = perl.pointee.newCV(name: name, file: file, body: body)
		if name != nil {
			pointer.pointee.refcntInc()
		}
	}

	deinit {
		pointer.pointee.refcntDec(perl: perl)
	}
}

%{
	def generic(p, r):
		g = ", ".join(map(lambda n: "P" + str(n) + ": PerlSVConvertible", range(0, p)) + map(lambda n: "R" + str(n) + ": PerlSVConvertible", range(0, r)))
		return "" if g == "" else "<" + g + ">"

	def tuple(prefix, count, optional):
		if optional == 0:
			return "(" + ", ".join(map(lambda n: prefix + str(n), range(0, count))) + ")"
		elif optional == 1:
			return "(" + ", ".join(map(lambda n: prefix + str(n) + "?", range(0, count))) + ")"
		else:
			return "(" + ", ".join([prefix + "0"] + map(lambda n: prefix + str(n) + "?", range(1, count))) + ")"

	def optrange(count):
		return range(0, (count + 1) if count < 3 else 3)
}%

extension PerlCV {
% for p in range(0, 8):
%   for r in range(0, 3):
%     args = ", ".join(map(lambda n: "P" + str(n) + ".cast(from: stack.args[" + str(n) + "])", range(0, p)))
%     for po in optrange(p):
%       for ro in optrange(r):

	@discardableResult
	convenience init${generic(p, r)}(name: String? = nil, file: StaticString = #file, body: @escaping ${tuple("P", p, po)} throws -> ${tuple("R", r, ro)}) {
		self.init(name: name, file: file) {
			(stack: UnsafeXSubStack) in
%         if r == 0:
			try body(${args})
			stack.xsReturn(EmptyCollection())
%         elif r == 1:
			let result = try body(${args})
			stack.xsReturn(CollectionOfOne(result.newUnsafeSvPointer(perl: stack.perl)))
%         else:
			let result = try body(${args})
			let svResult: ContiguousArray = [ ${", ".join(map(lambda n: "result." + str(n) + ".newUnsafeSvPointer(perl: stack.perl)", range(0, r)))} ]
			stack.xsReturn(svResult)
%         end
		}
	}

%       end
%     end
%   end
% end
}

extension PerlCV {
	@discardableResult
	convenience init<R: Collection>(name: String? = nil, file: StaticString = #file, body: @escaping (ContiguousArray<PerlSV>) throws -> R)
		where R.Iterator.Element == PerlSV {
		self.init(name: name, file: file) {
			(stack: UnsafeXSubStack) in
			let args = try ContiguousArray<PerlSV>(stack.args, perl: stack.perl)
			let result = try body(args)
			stack.xsReturn(ContiguousArray<UnsafeSvPointer>(result, perl: stack.perl))
		}
	}
}

extension PerlMappedClass {
% for p in range(0, 8):
%   for r in range(0, 3):
%     for po in optrange(p):
%       for ro in optrange(r):

	@discardableResult
	static func createPerlMethod${generic(p, r)}(_ method: String, file: StaticString = #file, body: @escaping ${tuple("P", p, po)} throws -> ${tuple("R", r, ro)}) -> PerlCV {
		return PerlCV(name: perlClassName + "::" + method, file: file, body: body)
	}

%       end
%     end
%   end
% end

	@discardableResult
	static func createPerlMethod<R: Collection>(_ method: String, file: StaticString = #file, body: @escaping (ContiguousArray<PerlSV>) throws -> R) -> PerlCV
		where R.Iterator.Element == PerlSV {
		return PerlCV(name: perlClassName + "::" + method, file: file, body: body)
	}
}
